\documentclass[a4paper]{scrartcl}

% Für mathematische Symbole
\usepackage{mathtools}
\usepackage{amsfonts}

\usepackage{import}

\usepackage{polyglossia}
\setdefaultlanguage[ 
	spelling = new, 
	babelshorthands = true ]
{german}

% Für Pseudo-Code
\usepackage[ruled,vlined]{algorithm2e}

%Hyperlinks
\usepackage{hyperref}
\hypersetup{
	colorlinks   = true, %Colours links instead of ugly boxes
	urlcolor     = blue, %Colour for external hyperlinks
	linkcolor    = blue, %Colour of internal links
	citecolor   = red %Colour of citations
}

% Glossar
% nomain - wenn importiert
% automake - für autocompile
\usepackage[xindy, automake]{glossaries}
\subimport{../../../../KIT/LaTex/Glossary/}{MathematikGlossary}
\subimport{../../../../KIT/LaTex/Glossary/}{TheoretischeInformatikGlossary}
\subimport{../../../../KIT/LaTex/Glossary/}{TechnischeInformatikGlossary}

%Aritmethikoperationen
%\usepackage{basicarith}

%Für Farben
\usepackage[dvipsnames]{xcolor}
\definecolor{TextMarkerGelb}{RGB}{255, 255, 120}
\usepackage{soul}
\sethlcolor{TextMarkerGelb}

% Fonts
\usepackage{fontspec}
\usepackage{unicode-math}

\setmainfont{Roboto}
\setsansfont{Roboto}
\setmonofont{Roboto}

% Math-Font
\setmathfont{Roboto} % for math symbols, can be any other OpenType math font

% Aside Kommentar
\usepackage{marginnote}

% Package für bessere Liste
\usepackage{scrextend}

% Mehrere Zeilen in einer Table für einen Eintrag nutzen
\usepackage{multirow}

% Durchstreichen
\usepackage[normalem]{ulem}

% Coole Listen [Seperator-zeichen]
\usepackage[ampersand]{easylist}


%\DeclareMathSizes{10}{18}{12}{8}   % For size 10 text
%\DeclareMathSizes{11}{19}{13}{9}   % For size 11 text
%\DeclareMathSizes{12}{20}{14}{10}  % For size 12 text

% Paragraph-Einstellung
\usepackage[explicit]{titlesec}
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}[block]
{\normalfont\normalsize\bfseries}{}{0pt}{\uline{#1}}
\titleformat{name=\paragraph,numberless}[block]
{\normalfont\normalsize\bfseries}{}{0pt}{\uline{#1.}}

% \emph{} - ändern
\DeclareTextFontCommand{\emph}{\bfseries}

% Neuer Befehl für not <->
\newcommand{\nleftright}{\mathrel{\ooalign{$\Leftrightarrow$\cr\hidewidth$/$\hidewidth}}}

\makeglossaries

%opening
\title{Mitschrift Digitaltechnik und Entwurfsverfahren}

\author{Paul Züchner}


\begin{document}
	
	\maketitle
	\tableofcontents
	\newpage
	\printglossaries
	\section{Einführung}
	
	Digitaltechnik bildet die Grundlage für ein modernes Leben\\
	
	Vom Problem zur Hardware\\
	
	\subsection{Aufteilung technische Informatik}
			\begin{table}[h]
				\centering
				\begin{tabular}{ | c | r |}
					\hline
					\multirow{2}{*}{\textbf{Rechnerorganisation} } & Assemblerebene \\ \cline{2-2}
						& Maschinensprachebene \\ \cline{2-2}
						& Mikrobefehlsebene\\ \hline 
					\textbf{Digitaltechnik} & Ausführende Schaltungen \\ \hline
				\end{tabular}
				\caption{Aufteilung | Soft}
			\end{table}
		
		\begin{table}[h]
			\centering
			\begin{tabular}{ | c | r |}
				\hline
				\multirow{4}{*}{ \textbf{Rechnerorganisation} } & Problemstellung \\ \cline{2-2}
					& Algorithmen \\ \cline{2-2}
					& Hochsprachen \\ \cline{2-2}
					& Maschinensprache \\ \hline
				\multirow{3}{*}{\textbf{Digitaltechnik} } & Funktionsgruppen \( \implies \) Alu \\ \cline{2-2}
					& Gatter \( \implies \) logische Elementaroperationen  \\ \cline{2-2}
					& Elektronische Bauteile \\ \cline{2-2}
					\hline
			\end{tabular}
			\caption{Vom Problem zur Hardware  | Hard \newline \sout{Vom Problem zum Programm}}
		\end{table}
	
	\subsection{Datenverarbeitender Systeme}
		\subsubsection{Aufbau}
			\begin{figure}[h]
				\begin{description}
					\item [Elektronische Komponenten]
					Besitzt eine Vielzahl elektronischer Komponenten. Die Komponenten sind untereinander verbunden und bilden eine Struktur in sich.
					\item [Struktur] 
					Diese Gesamtheit liefert hoffentlich das \emph{gewünschte Verhalten}.
				\end{description}
			\caption{Aufbau}
			\end{figure}
	\subsubsection{Aufgaben}
		\begin{figure}[h]
			\begin{description}
				\item[Entwurf]
					Aus einzelnen Komponenten wird eine komplexe Struktur entworfen, welche das \emph{gewünschte Verhalten}, möglichst preisgünstig, zu bietet.
				\item[Analyse]
					Vorhersage und des \emph{Verhaltens} einer Struktur aus bekannten Komponenten.
			\end{description}
		\caption{Aufgaben}
		\end{figure}
	
	\subsubsection{Abstraktionsebenen}		
		\begin{figure}[h]
			\begin{enumerate}
				\item \emph{Verhalten} 
				\item \emph{Struktur}
				\item Strukturen
				\item \emph{Funktionen}
			\end{enumerate}
			\caption{Um die Komplexität beherrschen zu können, ist es notwendig, Abstraktionsebenen in den Entwurf einzufügen. Diese Hierarchisierung erleichtert den Entwurf als auch die Analyse.}
		\end{figure}
	
	\subsection{Entwurf}
		top down
		bottom up
		jojo
		
	\subsection{Lernziele}
	
		\begin{figure}[h]
			\begin{easylist}[itemize]
				& Verständnis verschiedener Darstellungsformen von Zahlen / Alphabeten in Rechnern.
				& Formale Schaltungsbeschreibung.
				& Kenntnisse
					&& der relevanten Speichertechnologien
					&& der technischen Realisierungsformen von komplexen Schaltungen.
					
				& Schaltungen
					&& Entwickeln
					&& Analysieren
					&& Verstehen
			\end{easylist}
		\end{figure}

	\subsection{Vorlesungsinhalte}
			\begin{easylist}[itemize]
				& Grundlagen der Informationsdarstellung
				& Schaltnetze
					&& Formale Grundlagen logischer Beschreibungen
						&&& Boolesche Algebra
						&&& Schaltalgebra
					&& Realisierung von Schaltnetzen
						&&& Layout
						&&& Schalter
						&&& Gatterebene
					&& Entwurf von Schaltnetzen
						&&& Die Beschreibung "klassischer" Verfahren zur Logikminimierung
					&& Laufzeiteffekte bei Schaltnetzen
					
				& Schaltwerke
					&& Formale Grundalgen
						&&& Schaltwerke als Implementierung von endlichen Automaten
					&& Entwurf synchronen \& asynchronen Schaltwerken
					&& Spezielle  Schaltwerksbausteine
						&&& Register
							&&&& Schieberegister
						&&& Zähler
						&&& Programierbare Bausteine
				
				& Rechnerarithmetik
					&& Verschiedene Verfahren \& Implementierungsmöglichkeiten
							&&& \glspl{Grundrechenart} / \gls{Arithmetik}
					&& Aufbau einer arithmetisch-logischen Einheit
			\end{easylist}
	
	\section{Grundlagen der Informationsdarstellung}
	
		\subsection{Zahlensysteme}
			\begin{figure}[h]
				\begin{easylist}{itemize}
					& Mensch
						&& Dezimal
					& Maschine
						&& Dual
						&& Oktal
						&& Hexadezimal
						
				\end{easylist}
				\caption{Zahlensysteme}
			\end{figure}
		
		\subsection{Zahlendarstellung}
			\subsubsection{Stellenwertsystem}
				Darstellung der Zahlen erfolgt in Form einer \emph{Kette} von Ziffern \( Z_i \) \reversemarginpar \marginnote{String}
				\[ \textcolor{Blue}{Z_n; \dots ; Z_0 } \textcolor{Red}{ ; Z_{-m} } \]
				Jeder Position i der \emph{Kette} ist ein Stellenwert zugeordnet die i-te Potenz der Basis des Zahlensystems
				\[ \textcolor{Blue}{  b^n, \dots , b^1 , 1, } \textcolor{Red}{ b^{-1}, \dots, b^{-m}  } \]
				Der Dezimalwert X der Zahl, gegeben durch die Ziffern Z, ergibt sich dann als Summe der Werte aller Einzelstellen \(z_i \times b^i \)
				\[ X_b = \textcolor{Blue}{ z_n \times b^n + \dots + z_0 } \textcolor{Red}{ + \dots + z_{-m} n^{-m} }= \sum_{i= -m}^{n} z_ib^i \]
			
			\subsubsection{Darstellung im Rechner}
				Einzelne binär Ziffern wie 0 und 1 heißen Bit, kleinste mögliche Informationseinheit.
				
				\begin{figure}[h]
				Probleme bei der Darstellung von Zahlen
					\begin{easylist}[itemize]
						& Endlicher Speicher
							&& Nur Zahlen mit endlicher Genauigkeit darstellbar
						& Über- / Unterläufe
						& Positive und negative Zahlen müssen unterscheidbar sein
						& Darstellung von Gleitkommazahlen
					\end{easylist}
				\end{figure}
			
			\subsection{Umwandlung}
				\subsubsection{Dezimalsystem \(\implies\) Basis b)}
					\begin{itemize}
						\item[Gegeben:] 
							Zeichenkette im Dezimalsystem.
						\item[Ziel:] 
							Bestimmung der Anzahl an Zeichen (p / q) und deren eigentlichen Werte y zur Basis b. 
					\end{itemize}
				\begin{align*}
					X_{10} &=  \text{ \hl{$ z_n 10^n + \dots + z_0 \times 10^0 + \dots + z_{-m} 10^{-m} $} } \\
								&= \text{ \hl{$ y_p b^p + \dots + y_0 \times 10^0 + \dots + y_{-q} b^{-q}  $} }\\
								&= \text{ \hl{$ X_b $} }
				\end{align*}
			
		\subsubsection{Division \( \neq_{100\%} \) Umkehrung der Multiplikation }
			\begin{align*}
			Z &\gets Dividend \\ 
			D &\gets Divisor \\
			Q &\gets Quotient \\
			R &\gets Rest \\
			\\
			Z &= D \times Q + R\\
			\frac{Z}{D} &= Q + \frac{R}{D}\\
			\\
			0 &\leq R < |D|\\
			\\
			\hline
			\\
			\frac{4}{\text{ \hl{$ - 3 $}}} &\implies Q = -1; \quad R =  1; \\ 
			\frac{\text{ \hl{$ - 4 $}}}{3} &\implies Q = -1; \quad R = -1; \\
			\\
			\hline
			\\
			\frac{4}{\text{ \hl{$ - 3 $}}} &= - 1 + \frac{1}{\text{ \hl{$ - 3 $}}} \\
			\frac{\text{ \hl{$ - 4 $}}}{3} &= - 1 + \frac{\text{ \hl{$ - 1 $}}}{3}
			\end{align*}		
			
	\subsubsection{Euklidischer Algorithmus}
		\begin{algorithm}[h]
			\DontPrintSemicolon
					
			\nl \( i \gets p \) \;
			\( D_i \gets X_{10} \) \;
			\( b^i \leq D_i < b^{i+1} \) \tcp*{Berechne p}
			\BlankLine
			\nl \( y_i \gets \frac{D_i}{b^i} \) \tcp*{ Berechne  }
			\( R_i \gets D_i \mod b^i \) \;
			\BlankLine
			\nl \Repeat{$ R_i = 0 \text{ oder } b^i \text{gering genug }$}{ 
				\( _i \gets p - 1 \) \;
				\( D_i \gets R_{i+1} \) \;
				\( y_i \gets \frac{D_i}{b^i} \) \tcp*{ \( b^i = \text{Umrechnungfehler} \) }
				\( R_i \gets D_i \mod b^i \) \;
			}
		\end{algorithm}
					 
		\begin{algorithm}[h]
			\caption{Beispiel: Euklidischer Algorithmus}
			\DontPrintSemicolon
					 		
			 		\( Z \gets 13_{10} \) \tcp*{Dezimal\( _{10} \) ins Dualsystem\( _{2} \)}
			 		\( b \gets 2 \) \;
					\BlankLine
					 		
					 \( p \gets \) HöchstePotenzKleiner(13, Basis b) \tcp*{\( 2^? \leq 13 < 2^?\) \\ \( \text{\hl{$2^3$}} \leq 13 < 2^4 \)}
					 \BlankLine
					 \begin{align*}
					 	13 &\div 2^3 &= \text{\hl{$ 1 $} Rest } 5 \\
					 	5 &\div 2^2 &= \text{\hl{$ 1 $} Rest } 1 \\
					 	1 &\div 2^1 &= \text{\hl{$ 0 $} Rest } 1 \\
				 		1 &\div 2^0 &= \text{\hl{$ 1 $} Rest } 0 \\
			 			&& Z \gets \text{\hl{$ 1101$}}_2 
			 		\end{align*}
					\end{algorithm}
				 	
				 	\begin{algorithm}[h]
				 		\caption{Beispiel: Euklidischer Algorithmus Hexadezimal}
				 		\DontPrintSemicolon
				 		
				 	
				 	\( 16^3 \leq 15741,233 < 16^4 \)
				 	
				 	\( Z \gets 13_{10} \) \tcp{\(15741,233_{10}\) ins Hexadezimalsystem\( _{16} \)}
				 	\( b \gets 16 \) \;
				 	\BlankLine
				 	
				 	\( p \gets \) HöchstePotenzKleiner(15741,233, Basis b) 
				 	\tcp*{\( 16^? \leq 15741,233 < 16^?\) \\ \( \text{\hl{$16^3$}} \leq 15741,233 < 16^4 \)}
				 	\BlankLine
				 	\begin{align*}
				 	&15741,233 &\div 16^3 &= &\text{\hl{$ 3 $} Rest } 5 \\
				 	&3453,233 &\div 16^2 &= &\text{\hl{$ D $} Rest } 1 \\
				 	&125,233 &\div 16^1 &= &\text{\hl{$ 7 $} Rest }  \\
				 	&13,233 &\div 16^0 &= &\text{\hl{$ D $} Rest }  \\
				 	&0,233 &\div 16^{-1} &= &\text{\hl{$ 3 $} Rest }  \\
				 	&0,0455 &\div 16^{-2} &= &\text{\hl{$ B $} Rest }  \\
				 	&0,00256 &\div 16^{-3} &= &\text{\hl{$ A $} Rest }  \\
				 	&0,000088593 &\div 16^{-4} &= &\text{\hl{$ 5 $} Rest }  \\
				 	&&&&Z \gets \text{\hl{$ 3D7D,3BA5 $}}_{16} 
				 	\end{align*}
				 	\end{algorithm}
			 	
				\subsubsection{Abwandlung Horner-Schemas}
					 Idee: Ganzzahligen und gebrochenen Anteil getrennt betrachten. \\
					 \marginnote{nach und nach}
					 Ziffern werden \emph{sukzessive}, beginnend mit der höchstwertigen Ziffer, berechnet:
					 \begin{align*}
						 G_b &= \sum_{1=0}^{n} z_i b^i 
						 \marginnote{\(G =\) Ganzzahl}\\
						 &=  ( [ \dots ([( z_n b + z_{n-1} ) b + z_{n-2} ] b + z_{n-3} ) b \dots ] b + z_1) b + z_0 \\
						 \\
						 15741_{10} &= ( [ ( 1 \times 10 + 5 ) \times 10 + 7 ] \times 10 + 4 ) \times 10 + 1 
						 	\text{ \marginnote{Beispiel:} }\\
						 &= ( [ ( 15 ) \times 10 + 7 ] \times 10 + 4 ) \times 10 + 1 \\
						 &= ( [  150 + 7 ] \times 10 + 4 ) \times 10 + 1 \\
						 &= ( [  157 ] \times 10 + 4 ) \times 10 + 1 \\
						 &= ( 1570 + 4 ) \times 10 + 1 \\
						 &= ( 1574 ) \times 10 + 1 \\
						 &= ( 15740 + 1 \\
						 &= 15741 \\
					 \end{align*}
					 
					 \paragraph{Konvertierung}
						 Die Ziffern \( y_p \text{bis } y_0 \) erhält man dadurch, \\
						 dass man die Zahl \( X_{10} \) durch Basis b dividiert und \\
						 denn Rest getrennt notiert.
						 \par
						 Usw. bis der Quotient verschwindet(?),\\
						 Die jeweiligen ganzzahligen Reste ergeben die Zahl \(G_b\) \\
						 von der niederwertigsten zur hochwertigsten Stelle. \\
						 
					\paragraph{Anwenndung des Horner-Schemas}
						\(\text{Interpretation von } X_b = \sum_{i = 0}^{b} Z_i b^i \text{ als Polynom} \) \\
						\begin{align*}
							X_b &= Z_3 x^3 + 2_2 x^2 + Z_1 x^1 + Z_0 x^0  \marginnote{b = x} \\
							&= [( Z_3 x + Z_2) x + Z_1] x + Z_0\\
							\\
							\hline
							\marginnote{Sukzessive Division} \\
							&[( Z_3 x + z_2 ) x + z_1] x +Z_0 &\div x &= (Z_3 X + Z_2) x + Z_1 &Rest Z_0 \\
							&( Z_3 x + z_2 ) x + z_ x  &\div x &= Z_3 X + Z_2 &Rest Z_1 \\
							&Z_3 x + z_2 &\div x &= Z_3 &Rest Z_2 \\
							&Z_3 &\div  x &= 0 &Rest Z_3 \\
							\\
							&X_b = Z_3 Z_2 Z_1 Z_0 \\
						\end{align*}
						 
					\paragraph{Beispiel: Hörner-Schemas}
						\( 28,25_{10} \) konvertieren zu Basis 7
						
						\begin{align*}
							\marginnote{I:}
							&28 \div 7 = 4 &\text{Rest } 0 & \implies Z_0 \\
							&4 \div 7 = 0 &\text{Rest } 4 & \implies Z_1 &\implies 21_{10} = 40_7 \\
							\\
							\marginnote{II:}
							&0,25 \times 7 = 1,75 &= 1 + 0,75 \\
							&0,75 \times 7 = 5,25 &= 5 + 0,25 &\implies G_b,25_{10} = G_b,\overline{15}_7 \\
							\\
							\marginnote{Unnötig wegen Periode}
							&0,25 \times 7 = 1,75 &= 1 + 0,75 \\
							&0,75 \times 7 = 5,25 &= 5 + 0,25 \\
							\\
							&\implies 28,25_{10} &=	40,\overline{15}_7\\
						\end{align*}
						
					\paragraph{Umwandlung des Nachkomma-Teils}
						TODO: Umsortieren\\
						Auch der gebrochene Teil
						\[ N_B = \sum_{i=-m}^{-1} Z_i b^i \]
						einer Zahl lässt sich entsprechend schreiben:
						\[N_B = [ ( \dots [ ( Z_{-m} b^{-1} + Z_{-m+1} ) b^{-1} + z_{ -m + 2 } ] b^{-1} + \dots + z_{-2} ) b^{-1} + z_1 ] b^{-1} \]
					\paragraph{Verfahren:}
					 	Sukzessive Multiplikation des Nachkommateils der Dezimalzahl \\
					 	mit der Basis b des Zielsystems.\\
					 	\implies Die \(y_{-i} \) Nachkomma-Ziffern, \\
					 	in der Reihenfolge der höchstwertigen zur niedrigstwertigen Nachkommaziffer.\\
					 	
		\subsection{Spezialfall Zielbasis ist ein Mehrfaches von der Ursprungsbasis}
			Potenz herausfinden, muss vielfaches ergeben.
			Vom Komma ausgehend, Päckchen bilden, Länge der Potenz des Vielfachen.\\
			Nullen auffüllen falls an den rändern nich aufgeht \\
			\( 2^4 = 16 \) Vier Ziffern zusammenfassen \\
			\( 2^3 = 8 \)	Drei Ziffern zusammenfassen \\
			\paragraph{Beispiel: Dual in Hexadezimal}
			\[
				0110100,110101_2
				\begin{aligned}
					011&0100&,1101&01 \\	
					\implies (0 011)&(0100)&,(1101)&(01 00) \marginnote{Nullen auffüllem} \\
					\implies (3)&(4)&,(D)&(4)
				\end{aligned}
				34,D4_{16}
			\]
					 	
			\subsection{Negative Zahlen}
				Verschiedene Möglichkeiten: \\
				\subsubsection{Betrag und Vorzeichen}
					Eine stelle wird als Vorzeichenbit genutzt: MSB\\
					\begin{align*}
						&00010010 = 18\\
						&10010010 = -18\\
					\end{align*}
					
					
					\paragraph{Beispiel:}
					Vorzeichenlose Zahl \( 18_{10} =10010_2 \) \\
					Vorzeichen-Betrags-Darstellung: \\
					\begin{align*}
						18_{10} = 010010_{6Bits} = 0001 0010_{8 Bits} \\
						-18_{10} = 110010_{6Bits} = 1001 0010_{8Bits} \\
						\\
						18_{10} = 0000 0000 0001 0010_{16 Bits}\\
						-18_{10} = 1000 0000 0001 0010_{16Bits}\\	
					\end{align*}
										
					\paragraph{Vorteil:}
					\begin{description}
						\item[+] Symetrischer Zahlenbereich
					\end{description}
					
					\paragraph{Nachteil:}
						\begin{description}
							\item[--] 
								Zweimal die Null: 0000 und 1000
							\item[--] 
								Addition \& Subtraktion muss gesondert beachtet werden.
						\end{description}
					
				\subsubsection{Beispiel: Problem bei der Addition}
					\[
						\begin{aligned}
							2& \\
							-4& \\
							= -2& \\
							\\
							0010& \\
							1100&\\
							=1110& \\
							= -6 \neq 2&\\
						\end{aligned}
					\]
					\paragraph{Schlecht in die Realität umsetzbar}
					Schaltung müsste also erst herausfinden welcher Betrag ist größer, \\
					dann das Vorzeichen berechnen und\marginnote{+ 1 Vergleich} \\
					dann Beträge verrechnen\\
					\( \implies \)viel zu kompliziert um Software- als auch Hardware-technisch umsetzbar.\\
					
				\subsubsection{Einerkomplement aka. Stellenkomplement}
					\[
					Z_{EK} = (2^n -1) - Z_{(iffer)}\\
					\]
					\[
					Z = -(2n -1) + z_{n-1} \times 2^{n-1} + \dots +z_0
					\]
					\textbf{Positive Zahlen} \( \gets \) normale positive Dualzahlen \marginnote{MSB nicht gesetzt 0} \\
					
					\textbf{Null} \( \gets \) 0000 und 1111\\
					\\
					\textbf{Negative Zahlen} \( \gets \) negation der positiven Dualzahlen \marginnote{MSB gesetzt 1} \\
					
					
					\paragraph{Vorteile:}
						\begin{description}
							\item[+] Symetrischer Zahlenbereich
							\item[+] Erste Stelle bei der Addition und Subtraktion muss nicht gesondert bedtrachtet werden.
						\end{description}
					
					\paragraph{Nachteile:}
						\begin{description}
							\item[--] 
								Zweimal die Null: 0000 und 1111
							\item[--]
								 Wenn die Operation die Null überschreitet, können falsche Ergebnis entstehen, wenn letzte Übertrag nicht beachtet wird.
						\end{description}
					
					\subsubsection{Beispiel: Einerkompliment Transformation}
	
						\begin{align*}
							Z_{(iffer)} &= Z_{n-1} \dots Z_0 \marginnote{n Stellen} \\
							Z_{EK} &= Z_{n-1} \dots Z_0 \\
							\\
							Z_{EK} &= (2^n) - Z \marginnote{negieren/Minus}\\
							\\
						\end{align*}
					
					\paragraph{\(7_{10}\) ins Einerkompliment transformieren}
						\begin{align*}
							Z_{10} &= 7_{10}  \\
							&= 0_3 1_2 1_1 1_0 &n=4 \marginnote{n \gets Anzahl der Stellen}\\
							\\
							Z_{EK} &= (2^4 -1)-7 \\
							&= 15-7 \\
							&= 8_{10} \\
							&= 1000_2\\
						\end{align*}
	
						\begin{align*}
							&2^4 &1_4 0_3 0_2 0_1 0_0 = 10000\\
							&-1 &-00001\\
							\hline 
							&=15 &=01111\\
							&-7 &0111\\
							\hline
							&=8 &1000
						\end{align*}
					
					\subsubsection{Zweierkompliment}
					
						Man addiert nach der Stellenkomplemten noch eine \( 1 \)\\
						\[ Z_{ZK} = 2^n - Z \]
						Bitfolgen \( z_{n-1} \dots z_0 \) haben den Dezimalwert:\\
						\[ Z = - 2^n + z_{n-1} \times 2^{n-1} + \dots + z_0 \]
						
						\textbf{Positive Zahlen} \(\gets\) positive Dualzahlen\\
						\textbf{Null} \(\gets\) 0000
						\textbf{Negative Zahlen} \(\gets\) positive Dualzahl negation; + 1;\\
						
						\paragraph{Vorteil:}
							\begin{description}
								\item[+] Nur eine Null.
							\end{description}
						\paragraph{Nachteil:}
							\begin{description}
								\item[--] Asymetrischer Zahlenbereich
							\end{description}
						
						\paragraph{Eigenschaften}
							\begin{easylist}[itemize]
								& Kann als Kreis dargestellt werden.
								& Negative Zahlen werden um eins verschoben.
								& Erste Stelle gibt Vorzeichen an
							\end{easylist}
								
					\subsubsection{Beispiel: Zweierkompliment Transformation}
						Dezimalzahl \\ 
						\( \implies \) Dualzahl \\
						\( \implies \) Einerkomplement \\
						\( \overset{+ 1}{\implies} \) Zweierkomplement\\
						
						\paragraph{7 ins Zweierkomplement transformieren}
						Zur Erinnerung: \\
						\begin{align*}
							Z &= Z_{n-1} \dots Z_0 \\
							Z_{ZK} &= \overline{Z}_{n-1} \dots \overline{Z}_0 +1 \marginnote{\(\overline{Negation}\)}\\
						\end{align*}
						
						
							\begin{align*}
								7&_{10} \\
								0111&_{2} \\
								1000&_{EK}\\
										1&\\
								\hline
								1001&_{ZK} \\
							\end{align*}
						\paragraph{\(1001_{ZK} \) ins Dezimalsystem transformieren}
							\begin{align*}
								1001 &\implies n=4 \\
								\\
								Z &= - 2^4 + 1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0\\
								&= -16 + 8 +1\\
								&= -7 \\
							\end{align*}
							
						\paragraph{Weitere Beispiele}
							\ul{Gesucht:} Darstellung von \(-5\) im Zweierkomplement\\
							Es sei \( n = 4 \)\\
							\begin{align*}
								n&=4\\
								&\implies N= 2^4\\
								&= 16 \text{ Zahlen}\\
								\\
								-5& \doteq (16 - 5)_{10} \\
								&= 11_{10} \\
								&\doteq 1011_2\\ 
							\end{align*}
							\ul{Gesucht:} Darstellung von -14 im ZK
							\begin{align*}
								n&=4\\
								&\implies N= 2^4\\
								&= 16 \text{ Zahlen}\\
								\\
								-14 &\doteq (16 -14)_{10}\\
								&= 1_{10} \\
								&= 0010\\
								&\text{FALSCH!}
							\end{align*}
							
						\paragraph{Warum ist das so?}
							Man muss beachten wie groß das Ziel n wird.\\
							\begin{align*}
								(0)1110& \\
								(1)0001&\\
								1&\\
								\hline
								(1)0010
							\end{align*}
					\((Zahl) \coloneqq \) Übertrag wurde vergessen und deswegen ist das Ergebnis falsch.\\
					\subsubsection{Wie groß ist unser n?}
						\paragraph{Wichtig:}
							Immer nachdenken, wie viele Bits (n) für eine korrekte Darstellung notwendig sind!\\
							\paragraph{-14 im Zweierkomplement}
							\begin{align*}
								n &= 5\\
								\implies N &= 2^5\\
								&= 32\\
								\\
								-14 &\doteq 32 - 14 \\
								&= 18_{10} \\
								& \doteq 10010_2\\
							\end{align*}
							
						\paragraph{-77 transformiert in Zweierkomplement}
							\begin{align*}
								77_{10} &= 0100 \quad 1101_2 \\
								\\
								-77 &= (1)100 \quad 1101_2 \marginnote{-77}\\
								\hline
								&= 1011 \quad 0010_2 \marginnote{EK}\\
								&= 1011 \quad 0011_2 \marginnote{+1, ZK}\\
							\end{align*}
					
					\subsubsection{Offset-Dual-Darstellung/ Exzess-Darstellung}
						\paragraph{Eigenschaften}
							\begin{easylist}[itemize]
								& Hauptsächlich Exponenten-Darstellung von Gleitkommazahlen
								& Eine Zahl wird als Charakteristik dargestellt
								& Der Zahlenbereich wird durch einen konstanten Offset so nach oben verschoben, dass die kleinste Zahl die Darstellung \(0 \dots 0\) erhält.
								& Bei n Stellen ist Offset \(2^{n-1}\)
								& Zahlenbereich asymetrisch
							\end{easylist}
						
						\paragraph{Am Beispiel von \(2^3\)}
							\textbf{Positive Zahlen} \( \gets \) MSB 1 \\
							\textbf{Null} \( \gets \) "Mitte" 100\\
							\textbf{Negative Zahlen} \( \gets \) 101 bis 111\\ 
						
						\paragraph{Vorteil:}
							\begin{description}
								\item[+] Es existiert nur eine Null
							\end{description}
						\paragraph{Nachteil:}
						\begin{description}
							\item[--] asymetrischer Zahlenbereich
						\end{description}
				
			\subsubsection{Festkommazahlen}
				\paragraph{Unterschied zwischen Papier und Rechner}
				
				\begin{table}[h]
					\centering
					\begin{tabular}{ | l | c | c |}
						\hline
						  & Papier & Computer \\ \hline
						Ziffern & \(0\dots 9 \) & 0,1 \\ \hline
						Vorzeichen & \( +- \) & \\ \hline
						Komma & , &  \\ \hline
					\end{tabular}
				\caption{Zahlendarstellung Papier vs. Rechner}
				\end{table}
			\( \implies  \) Konvention über Vorzeichen und Komma wird benötigt.\\
			Vorzeichen: sehe vorherigen Abschnitt. \\
			
			\paragraph{Komma-Darstellung}
			\begin{easylist}[enumerate]
				& Festkomma
					&& Komma sitzt an einer festen Stelle
						&&& Integer
					&& Maßstab wird verwendet
						&&& \( 2,9 \times 1.000 \)
				& Gleitkomma
					&&
			\end{easylist}
		
			\paragraph{n Vor- und m Nachkommastellen}
				\begin{align*}
					Inhalt...
				\end{align*}
				\paragraph{Größtmögliche Zahl}
				\begin{align*}
					Z_2 &= 0^n 1^{n-1} \dots  1^0, 1^{-1}, \dots 1^{-m}\\
					Z_{10} &= 2^{n-1} \dots 2^1 \times 2^0, 2^{-1} \dots 2^{-m}\\
					2Z &= 2^n + 2^{n-1} + \dots \quad +2^{-m+1}\\
					\hline
					Z &= 2Z - Z\\
					&= 2^n -6^{-m}\\
				\end{align*}
				\paragraph{Kleinstmögliche Zahl}
				\begin{align*}
					Z&= 0\dots 0,0 \dots 01\\
					&= 2^{-m}
				\end{align*}
				
			\paragraph{Vorteile}
				\begin{description}
					\item[+] 
				\end{description}
			
			\paragraph{Nachteile}
				\begin{description}
					\item[--] Keine ganz großen bzw. ganz kleinen Zahlen darstellbar
					\item[--] Keine Abgeschlossenheit
					\item[--] Assoziativgesetz und Distributivgesetz gelten nicht
				\end{description}
			
		\subsubsection{Gleitkommazahlen}
			\paragraph{Vorteile}
			\begin{description}
				\item[+] Zur Darstellung von Zahlen, die Betragsmäßig sehr groß oder sehr klein sind, verwendet man die 			Gleitkomma-Darstellung
			\end{description}
			
			\paragraph{Nachteile}
			\begin{description}
				\item[--] a
			\end{description}
			
			\paragraph{Eigenschaften}
				\begin{easylist}[itemize]
					& Sie entspricht einer halblogarithmischen Form
						&& \( X = \pm Mantisse \times b^{Exponnent} \)
					& Die Basis b ist für eine bestimmte Gleitkomma-Darstellung fest und braucht damit nicht mehr explizit repräsentiert werden.
					& Wird meist im Betrag-Vorzeichen-Form dargestellt
				\end{easylist}
			\paragraph{Normalisierung}
				Implizierte 1 wird weggelassen + 1 bit mehr Genauigkeit\\
			\paragraph{Warum Normalisierung}
				Im Rechner nur endliche Anzahl an stellen\\
				Möglichst viele signifikante Stellen\\
			\paragraph{Normalisierung im Dezimalsystem}
				\begin{align*}
					1160 km &= 1160 \times 10^3 m\\
					&= 11,60 \times 10^5 \\
					&= 1,160 \times 10^6 m  \\ 
				\end{align*}
				\marginline{Normalisiert}
				
			\paragraph{Beispiel: Drei verschiedene 32 - Bit- Zahlenformate mit Basis b=2}
				7135 Hexadezimal\\
				und normalisiert\\
				Komma um 13 Stellen nach links verschoben\\
				\( \times 2^{-13}\) \\
				Minute 1:09:00\\
				Implizierte 1 kann weggelassen werden\\
				
			\paragraph{Darstellbarer Zahlenbereich}
				Format a\\
				Format b\\
				Format c: implizierte Darstellung, null kann nicht mehr dargestellt werden.\\
				Größte darstellbare Zahl\\
				Kleinste darstellbare Zahl \\
				
				
			
		
		
			\subsection{Zahlen \& und Zeichendarstellung }
			
				\subsubsection{BCD - Kodierung}
					\begin{easylist}[itemize]
						& BCD überführt Dezimalzahlen ziffernweise in eine Binärdarstellung.
						& In der BCD-Kodierung werden immer 4-Bits gruppiert. So eine Gruppe wird auch \hl{Tetrade} genannt (siehe auch: Tetradenkodierung)
						& \( 2^4 = 16\) daher stellen 6 der 16 möglichen Kodierungen keine gültige Darstellung da, diese werden auch \hl{Pseudotetraden} genannt.
					\end{easylist}
				
				\subsubsection{Gray - Kodierung}
					Die Gray-Kodierung nutzt Binärzeichen, Besonderheit ist beim Gray-Kode dass nur pro Zählschritt, ein \hl{Zeichen geändert wird}. 
					\paragraph{Beispiel:} 
					\[ 3 \rightarrow 4 \] \[ 0010 \rightarrow 0110 \] statt \[ 0011 \rightarrow 0100 \]\\
					Solche Kodierungen heißen ein\emph{schritt}ige Kodierungen.
					
					\paragraph{Eigenschaften:}
					
					\begin{easylist}
						& Vorteile:
							&& Die einschrittige Kodierung bietet Vorteile bei der Analog/Digital-Wandlung 
							&& und für mechanische Abtaster.
						& Nachteile:
							&& Die Stellen besitzen keine feste Stellenwertigkeiten.\\
									Das macht die Ausführung von arithmetischer Operationen schwierig!
					\end{easylist}
					
					\paragraph{Gray-Kodierung: 0 - 15}
					\begin{table}
						\centering
						\begin{tabular}{c|c}
							0&\hl{0}000\\
							1&000\hl{1}\\
							2&00\hl{1}1\\
							3&001\hl{0}\\
							4&0\hl{1}10\\
							5&011\hl{1}\\
							6&01\hl{0}1\\
							7&010\hl{0}\\
							8&\hl{1}100\\
							9&110\hl{1}\\
							10&11\hl{1}1\\
							11&111\hl{0}\\
							12&1\hl{0}10\\
							13&101\hl{1}\\
							14&10\hl{0}1\\
							15&100\hl{0}\\
						\end{tabular}
					\end{table}
					
					\paragraph{Umwandlung von Dual- in Gray}
					\begin{algorithm}[H]
						\caption{Dual- \( \rightarrow \) in Gray-Kode }
						\DontPrintSemicolon
						
						\( X_1 \coloneqq \text{ Dualzahl} \)\; 
						\BlankLine
						\( X_2 = X_1 \times 2 \)  \tcp*{Entspricht Linksschieben um 1}
						\( X_3 = (X_1 + X_2) \mod 2 \) \tcp*{Modulo-2 \& Addition \( \rightarrow \) \( X_1\) XOR \( X_2 \) }
						\( X_4 = X_3 \div 2 \) \tcp*{Entspricht Rechtssschieben um 1}
						\BlankLine
						\( X_4 \coloneqq \text{ Gray-Kode für } X_1\) \;
					\end{algorithm}
					
					\paragraph{Berechnungsbeispiel: 1111 in Gray-Kode}
					\begin{align*}
						X_1 &= 1111_2\\ 
						X_2 &= X_1 \times 2\\ 
								&= 1\; 1110\\
						X_3 &= (X_1 + X_2) \mod 2\\ 
						\\
						&1111\\
						\text{XOR } 1\; &1110 \\ \hline
						X_3 \gets 1 \;& 0001\\
						\\
						X_4 &= X_3 \div 2 \\ 
						&= 1000 \\
						&  \text{ Gray-Kode} 
					\end{align*}
					
				\subsubsection{ASCII}
					\~{} nutzt 5 Bits für die Kodierung für:\\
					\begin{easylist}
						 & \( 2 \times 26  \) Buchstaben
						 & 10 Ziffern
						 & 32 Kommunikationssteuerzeichen
						 & 32 Interpunktionszeichen
					\end{easylist}
					Insgesamt sich \( 2^5 = 128 \) Zeichen möglich.\\
					Für zusätzliche Zeichen wie Umlaute oder andere nationale Besonderheiten reicht das nicht aus.\\
					Um trotzdem andere Alphabete umzusetzen, hatte man zwei Möglichkeiten:
					\begin{easylist}
						& Die Kodierung modifizieren
							&& ISO-7-Bit
							&& DIN 66003
									&&& Deutsches "ASCII" mit Umlauten
						& Ein Bit hinzufügen, um weitere 128 Zeichen kodieren zu können
							&& Vorteil: Man könnte das zusätzliche Bit zur Fehlererkennung einsetzen
					\end{easylist}
					
				\subsubsection{Unicode}
					Unicode ist die Erlösung von dem 7-8 Bit "F*ckfest" was bis in die 80er betrieben wurde. Die vorherigen Kodierungen waren zu spezifisch, nationale Besonderheiten, Firmenspezifisch...\\
					Asiatische Alphabete waren nicht oder nur mit komplizierten Hacks \footnote{komplizierte Kodierungssequenzen} nutzbar.\\
					\\
					Eine internationale, weltweite Norm war von Nöten, um einfachen Datenaustausch möglich zu machen.\\
					
					\paragraph{Geschichte:}
					Ende der 80er Jahre began das \emph{Unicode-Konsortium} mit der Entwicklung einer solchen Zeichenkodierung. Im Unicode-Konsortium waren viele Soft- und Hardwarefirmen vertreten wie Apple, IBM oder Microsoft. Der Umstieg von den alten uneinheitlichen Kodierung zum Unicode erfolgte nur sehr langsam.\\
					
					\paragraph{Eigenschaften:}
					\begin{easylist}
						& 16 Bits ermöglichen 65.536 Zeichen
							&& Alle 16 Bits stehen für die Zeichenkodierung zur Verfügung
								&&& Kodierungs-Schema: U+xxxx \footnote{ \(x \gets \) Hexadezimalzahl}
						& Kodiert werden nur Zeichnen
							&& Keine Zeichendarstellung oder Erscheinungsbild (z.B. die {\Large Größe} oder \textit{Kursiv})  
							&& Die Unicode-Norm kodiert einfachen (nicht formatierten) Text. Keine Kodierung von Schriftgröße, Farbe usw.
						& Unicode-Zeichen 
							&& haben eine wohl definierte Semantik \footnote{ /Bedeutung}
							&& werden in logischer Reihenfolge angeordnet.
								&&&  \( \rightarrow \) Lateinische Buchstaben von links nach rechts
								&&& \( \gets \) Arabische \& Hebräische von rechts nach links 
						& Gleiche Zeichen werden gleichgesetzt(?)
							&& Speziell bei Chinesisch, Japanisch, Koreanisch 
						& Unicode ermöglicht zusammengesetzte Zeichen dynamisch zu erstellen
							&& Ü = U+005 (+) U+0308
							&& Zusammengesetzte Zeichen sind häufig zusätzlich mit einem eigenen Identifierer vorhanden. Ü = U+00DC
						& 1zu1- Umsetzung zwischen Unicode und anderen weit verbreiteten Normen ist garantiert
					\end{easylist}
									
			\subsection{Fehlerkorrigierende Codes}
				\subsubsection{Fehlererkennung}
					\paragraph{Quersumme: Einfaches Schema}
					\begin{easylist}
						& Jedes Datenwort erhält ein zusätzliches Bit
						& Un-/gerade Parität
						& Zusätzlicher Speicheraufwand ermöglicht einfache Fehlerprüfung
					\end{easylist}
					 
					 \[ x_0 \oplus (x_1 \oplus \dots \oplus x_8) = 0_{9.Bit} \] \marginnote{Gerade Parität}
					 \ul{Gleichung wird falsch wenn:}
					 \begin{easylist}
					 	& einzelnes Bit oder
					 	& eine ungerade Zahl von Bits fehlerhaft geworden sind
					 \end{easylist}
					 \BlankLine
					 \hl{Verfälschung einer geraden Zahl von Binärstellen ist nicht erkennbar,\\
					 Kode kann keine Fehler erkennen\\}
				 	 \BlankLine
				 	 \ul{Auch möglich:}
				 	 \begin{easylist}  
				 	 	& odd parity 
				 	 		&Man kann ein Paritätsbit anfügen, das zu einer geraden Anzahl von Einsen führt und die ungerade Anzahl überprüfen 
				 	 \end{easylist}
					 
					 \paragraph{Redundante Kodierung: 7-Bit-Kodierung mit gerader Parität }
					 \[ x_0 = x_1 \oplus \dots \oplus x_7 \]
					 \ul{Fehlererkennung: }\\
					 \\
					 8-Bit-Kodierung mit gerader Parität\\
					 \[ x_0 \oplus (x_1 \oplus \dots \oplus x_7) = 0_{8.Bit}\]
					
					
				\subsubsection{Fehlerkorrektur / Hammingcode}
					\ul{Gewünscht wird: }\\
					\begin{easylist}
						& Position des Fehler herausfinden können
							&& Mehr als ein Prüfbit notwendig
						& Fehlerhafte Kodewörter sind nur bis zu bestimmten Grenzen korrigierbar
						& Die Korrekturbits sind eindeutig kodiert
							&& ob und ggf. welche Bits im gesamten Kodewort (Daten- und Korrekturbits) fehlerhaft sind
					\end{easylist}
					\paragraph{Anzahl der benötigten Prüfbits}
						\begin{easylist}
							& Anzahl der Bits eines zu übertragenden Codewort
								&& n Bits
							& Einer der n Bits kann falsch sein
								&& \(\implies \) n Fehlerfälle
								&&		+ 1 \text{ Fehlerfreien Fall}
							& -Kodierung der (n+1) Fälle durch k Prüfbits
								&& \( 2^k \geq n + 1 \)
							& k Prüfbits sind Teil vom Codewort \\
								\(\implies n = m + k \)\\
								\hl{$\implies 2^k \geq m + k +1$} \\
						\end{easylist}
					\paragraph{Aufbauprinzipien}
						\begin{description}
							\item[Hier:] Einfaches Realisierungsschema
							\item[Vorteil:] Beliebige Erweiterbarkeit auf größere Datenwortlängen
							\item[Der Ansatz:] Verwende k verschiedene Prüfgleichungen für die Quersummen \( QS_0 \text{ bis } QS_{k-1} \)
						\end{description}
					
					\paragraph{Einfaches Aufbauprinzip}
					\ul{Beispiel: 7-Bit Codewort}  \\
					 \begin{align*}
					 	 &\overset{7}{x} \overset{6}{x} \overset{5}{x} \overset{4}{x} \overset{3}{x} \overset{2}{x} \overset{1}{x}\\
					 	&m = 4 &| \text{Anzahl der Datenbit}\\
					 	&k \gets k_3 k_2 k_1 = 3 &| \text{Anzahl der Korrekturbits} \\
					 	\\
					 	&4 + 3 = 7 \quad (;\\
					 \end{align*}
					 -- \emph{Sogennannte Syndrome} aus \( k_3 k_2 k_1 \) sollen die Position des fehlerhaften Bits im Codewort kodieren\\ 
					
					\begin{table}[h]
						\centering
						\begin{tabular}{c | c c c }
							Fehlerposition	&\(k_3\) &\(k_2\) & \(k_1\) \\ \hline
							1& 0 & 0 &1\\
							2 &0&1&0\\
							3 &0&1&1\\
							4 &1&0&0\\
							5 &1&0&1\\
							6 &1&1&0\\
							7 &1&1&1\\
							\hl{Kein Fehler}&0&0&0
						\end{tabular}
						\caption{Fehlererkennung mittels Syndrome}
					\end{table}
					
					\paragraph{Ansatz}
						Die i-te Quersumme ergänzt alle Positionen im Kodewort,\\
						die die Potenz \(\text{Basis}^i = 2^i  \) in ihrer Ziffernwertigkeit enthalten auf gerade Parität.\\
						\begin{align*}
							k_1 = 2^0 = 1 \text{ springen, 1 nehmen } =  QS_0 &\text{ über alle ungeraden Stellen } 1,3,5 \\
							k_2 = 2^1 = 2 \text{ springen, 2 nehmen } =  QS_1 &\text{ über die Stellen } 2,3,6,7, 10 \\
							k_3 = 2^2 = 4 \text{ springen, 4 nehmen } = QS_2 &\text{ über die Stellen } 4, 5, 6, 7, 12,  \\
							k_4 = 2^3 =  8 \text{ springen, 8 nehmen } = QS_3 &\text{ über die Stellen } 8, 9, 10, 11, 12 \\
						\end{align*}
						
						\begin{table}[h]
							\centering
							\begin{tabular}{c c c c}
								\(k_3\) &\(k_2\) & \(k_1\)& \( k_0 \)\\
								0&0&0&1\\
								0&0&1&0\\
								0&0&1&1\\
								0&1&0&0\\
								0&1&0&1\\
								0&1&1&0\\
								0&1&1&1\\
								1&0&0&0\\
								1&0&0&1\\
								1&0&1&0\\
								1&0&1&1\\
								1&1&0&0\\
								1&1&0&1\\
								1&1&1&0\\
								1&1&1&1\\
							\end{tabular}
						\end{table}
					
					--Es werden gerade Quersummen verwendet\\
					--Datenwörter werden zum Einfügen der Prüfbits gespreizt\\
					indem die Kodewortposition \( 2^i \) für die i-te Quersummenprüfstelle \( k_{i+1} \) freigehalten wird \\
					( \( m_i  \) bezeichnet die Datenbits)\\
					
					Annahme wir haben nur ein Bit-Fehler\\
					Durch erneutes Bilden der Quersummen kann ob und an welcher Position sich der Fehler befindet ermittelt werden \\
					Die Quersummen \( Syndrom k_u \dots k_2 k_1 \) werden dann, als Dualzahl interpretiert, die fehlerhafte Position im Kodewort angibt.\\
					Liegt kein Fehler vor,
					dann sind alle Prüfgleichungen erfüllt.\\
					
					\paragraph{Hammingkode mit 4 Datenbits und 3 Prüfbits, also 7-Bit-Kodewörter}
					\emph{Datenwort:} 1101
					\begin{align*}
						&\implies xxxxxxx&\\
						&\implies 1_{m_4} 1_{m_3} 0_{m_2} k_3^{2^2} 1_{m_1}  k_2^{2^1} k_1^{2^0}&\\
					\end{align*}
					
					\ul{Bestimmung der Prüfbits}\\
					\begin{align*}
						k_1 = m_1 \oplus m_2 \oplus m_4 = 1 \oplus 0 \oplus 1 &= 0\\
						k_2 = m_1 \oplus m_3 \oplus m_4 = 1 \oplus 0 \oplus 1 &= 1\\
						k_3 = m_2 \oplus m_3 \oplus m_4 = 1 \oplus 0 \oplus 1 &= 0\\ \hline
						&\implies \text{Kodewort } 110 k_3 11 k_2 k_1\\
						&\implies \text{Kodewort } 1100110\\
					\end{align*}
					
					--\hl{Prüfbits können auch verfälscht sein.} \\
					
					Generatormatrix? \\
					\begin{table}
						\centering
						\begin{tabular}{| c | c | c | c | c | c | c | c |}
							\hline
							7&6&5&4&3&2&1\\
							\(m_4\)&\(m_3\)&\(m_2\)&\(k_3\)&\(m_1\)&\(k_2\)&\(k_1\)\\ \hline
							X&&X&&X&&X&\(k_1\)\\
							X&X&&&X&X&&\(k_2\)\\
							X&X&X&X&&&&\(k_3\)\\ \hline
						\end{tabular}
						\caption{StellenwertigkeitsBereich}
					\end{table}
					\paragraph{Generatormatrix <- Datenwort \& Codewort}
					\[
						\begin{bmatrix}
							1&0&0&0\\
							0&1&0&0\\
							0&0&1&0\\
							1&1&1&0\\
							0&0&0&1\\
							1&1&0&1\\
							1&0&1&1\\
						\end{bmatrix}
						\begin{bmatrix}
							m4\\
							m3\\
							m2\\
							m1\\
						\end{bmatrix}
						=
						\begin{bmatrix}
							m_4\\
							m_3\\
							m_2\\
							k_3\\
							m_1\\
							k_2\\
							k_1\\
						\end{bmatrix}
					\]
					
					\[ \text{\underline{Genrator Matrix} }\times \text{\underline{Datenwort}} = \text{\underline{Kodewort}} \]
					\paragraph{Generatormatrix <- Codewort \& Syndrom}
					\[
						\begin{bmatrix}
							1&1&1&1&0&0&0\\
							1&1&0&0&1&1&0\\
							1&0&1&0&1&0&1\\
						\end{bmatrix}
						\begin{bmatrix}
							m_4\\
							m_3\\
							m_2\\
							k_3\\
							m_1\\
							k_2\\
							k_1\\
						\end{bmatrix}
						=
						\begin{bmatrix}
							k_3\\
							k_2\\
							k_1\\
						\end{bmatrix}
					\]
					
				\paragraph{Generatormatrix <- Codewort \& Datenwort}
					\[
						\underline{\text{Datenwort}} = 
						\begin{bmatrix}
							m_4\\
							m_3\\
							m_2\\
							m_1\\
						\end{bmatrix}
						=
						\begin{bmatrix}
							1\\
							1\\
							0\\
							1\\
						\end{bmatrix}
					\]
					\[
						\underline{\text{Codewort}} = \underline{\text{Generatormatrix}} \times \underline{\text{Datenwort}}=
						\begin{bmatrix}
							m_4\\
							m_3\\
							m_2\\
							k_3\\
							m_1\\
							k_2\\
							k_1\\
						\end{bmatrix}
						=
						\begin{bmatrix}
							1\\
							1\\
							0\\
							0\\
							1\\
							1\\
							0\\
						\end{bmatrix}
					\]
					\[
						\begin{bmatrix}
							k_3\\
							k_2\\
							k_1\\
						\end{bmatrix}
						= \underline{H} \times \underline{CW} = 
						\begin{bmatrix}
							0\\
							0\\
							0\\
						\end{bmatrix}
					\]
					
				\paragraph{Finde den Fehler!}
					-- Fehlerhaftes Codewort:
					\[
						 \overline{\underline{CW}} = \underline{CW} + \underbrace{\underline{e_i}}_{i-ter Einheitesvektor} 
					\]
					\[
						\underline{H} \times \overline{\underline{CW}} = \underline{H} \times ( \underline{CW} + \underline{e_i} ) = \underbrace{\underline{H} \times \overline{\underline{CW}}}_{=\underline{0}} + \underbrace{\underline{H} \times \underline{e_i}}_{\text{i-te Spalte der H-Matrix}}
					\]
					\[
						\begin{bmatrix}
							k_3\\
							k_2\\
							k_1\\
						\end{bmatrix}
						\begin{bmatrix}
							1&1&1&1&0&0&0\\
							1&1&0&0&1&1&0\\
							1&0&1&0&1&0&1\\
						\end{bmatrix}
						\times
						\begin{bmatrix}
							1\\
							1\\
							0\\
							0\\
							0|Fehler\\
							1\\
							0\\
						\end{bmatrix}
						=
						\begin{bmatrix}
							0\\
							1\\
							1\\
						\end{bmatrix}
					\]
					
				\subsubsection{Hammingkode ?Vorher einfügen?}
				\begin{easylist}
					& gilt genau dann, wenn garantiert werden kann, dass tatsächlich nur 1-Bitfehler auftreten
					& kann mehrfache Bitfehler erkennen
						&& Aber nur 1-Bitfehler korrigieren.
					& \hl{Voraussetzung: Nur 1 - 2-Bitfehler treten auf!}
					& Im Fall von 2-Bitfehlern
						&& Können erkannt werden
						&& Aber nicht von 1-Bitfehlern unterschieden werden
				\end{easylist}
				\BlankLine
				
				\paragraph{Beispiel:}
				Bei dem Syndrom \(k_4 k_3 k_2 k_1 =\) 0101 \\
				-- Kann sowohl \hl{ein 1-Bitfehler an der 5. Position}\\
				-- Als auch ein \hl{2-Bitfehler} an \hl{zwei unbekannten Positionen} vorliegen.\\
				
				\paragraph{2-Bitfehler}
				\begin{easylist}
					& Um ein 1-Bitfehler von 2-Bitfehlern unterscheiden zu können, \\
					fügt man ein weiteres Paritätsbit hinzu.
					& 1-Bitfehler
						&& Erkennbar durch das Paritätsbit
						&& Korrigierbar durch den Hammingkode -> Aufspreitzung
					& 2-Bitfehler
						&& Nicht erkennbar durch das Paritätsbit
						&& Nicht korrigierbar aber erkennbar durch den Hammingkode -> Aufspreitzung
					& (n>2)-Bitfehler
						&& Andere Verfahren
				\end{easylist}
				
				\begin{align*}
					\text{Fall 1: }& \text{Keinen Fehler}\\
					& \overset{m_5}{0} \overset{k_4}{0} \overset{m_4}{1} \overset{m_3}{1} \overset{k_3}{0} \overset{m_2}{1}  \overset{m_1}{1} \overset{k_2}{0} \overset{k_1}{0} \overset{Pa}{0} & k_4 k_3 k_2 k_1 = 0000\\
					\\
					\text{Fall 2: }& \text{1-Bit-Fehler}\\
					&\overset{m_5}{0} \overset{k_4}{0} \overset{m_4}{1} \overset{m_3}{(0)} \overset{k_3}{0} \overset{m_2}{1}  \overset{m_1}{1} \overset{k_2}{0} \overset{k_1}{0} \overset{Pa}{0} & k_4 k_3 k_2 k_1 = 0110\\
					\\
					\text{Fall 3: }& \text{2-Bitfehler}\\
					&\overset{m_5}{0} \overset{k_4}{0} \overset{m_4}{1} \overset{m_3}{(0)} \overset{k_3}{0} \overset{m_2}{1}  \overset{m_1}{(0)} \overset{k_2}{0} \overset{k_1}{0} \overset{Pa}{0} & k_4 k_3 k_2 k_1 = 0101\\
				\end{align*}
				
				\begin{easylist}
					& An Standard-Codewörter lässt dich ein weiteres Quersummenbit anfügen,so dass Zweibitfehler im Codewort erkennbar werden.
					& 32-Bit Wortlänge werden durch 7 Prüfbits zur Einzelfehlerkorrektur und Doppelfehlererkennung ergänzt.
					& 64 Bit lange Datenwörter erfordern 8 Korrekturbits
					& Die Algebra endlicher Körper bietet über Generator- und Nullmatrix Verfahren, die zu jedem Datenwort ein Codewort erzeugen.
				\end{easylist}
			
			\subsection{1. Übung 2017}
			
				\subsubsection{Zahlendarstellungen}
				\begin{align*}
					&(11111)_{2} = 31_{10} \\
					&(11111)_{VZ,5} = -15_{10}\\
					&(11111)_{1K,5} = \pm 0_{10} \\
					&(11111)_{2K,5} = -1_{10} \\
					&(11111)_{2K,6} = 31_{10} \\
					&(11111)_{10} =  11.111_{10} \\
					&(11111)_{16} = 0x 01 11 11 = 69.905_{10}\\
				\end{align*}
				
				 \( \#_{VZ,5} \gets \) Vorzeichen-Betragdarstellung mit 5 Stellen\\
				 \( \#_{1K,6}\gets \) Einerkomplement mit 6 Stellen\\
				 
				 \subsubsection{Zahlen in das Zweierkomplement transformieren}
				 \begin{align*}
				 	&\text{Gesucht: Darstellung von -14 im ZweierKomplement }
				 	\\ \hline \\
				 	&n \gets 4\\
				 	&N\coloneqq \text{ Kombinationen}\\
				 	&N = 2^4 = 16 \\
				 	\\
				 	&-14 : N-z\\ 
				 	&= 16-14=2\\ 
				 	& \implies \text{\st{$0010$}}_{ZK,4}\\
				 	\\
				 	&\text{Warum falsch?}\\
				 	& \implies \text{Erste Zahl = 0}\\
				 	& \implies \text{ positiv }\\
				 	\\
				 	& N= 2^4 = 32 \\
				 	& \implies [-8;7]\\
				 	\\ \hline \\
				 	&n \gets 5\\
				 	&N = 2^5 = 32\\
				 	& \implies [-16;15]\\
				 	\\
				 	&-14 : N - z\\
				 	& = 32-14 \\
				 	&= 18 10010_{ZK,5}\\
				 \end{align*}
				
				\subsubsection{Addition Zweierkomplement}
				Zahlenkreis\\
				\paragraph{Es werden drei Fälle unterscheiden:}
				\begin{easylist}
					& Beide Summanden haben ein positives Vorzeichen
						&& \( \implies \) das Ergebnis muss positiv sein
							&&& Wenn Vorzeichenbit \ul{1} statt 0, also \ul{negative} wurde der Zahlenbereich überschritten \hl{(Überlauf)}
					& Beide Summanden haben ein negatives Vorzeichen
						&& \( \implies \) Das Ergebnis muss negativ sein
							&&& Wenn Vorzeichenbit \ul{0} statt 1, also \ul{positiv} wurde der Zahlenbereich überschritten (Überlauf)
					& Gilt für negativ negativ \& positiv positiv
						&& Die beiden vordersten \hl{Überträge/Carrybits} müssen den gleichen Wert haben
					& Summanden haben unterschiedliche Vorzeichen
						&& Das Ergebnis ist auf jeden Fall korrekt
						&& Das Vorzeichen hängt davon ab, ob Subtrahend oder Minuend betragsmäßig größer sind
						&& Der Übertrag aus der vordersten Stelle ist zu streichen
				\end{easylist}
				
				TODO: Beipiele hinzufügen 05\\
				
				\subsubsection{Überlauferkennung}
				\paragraph{Allgemeine Überlauferkennung bei dualer Addition:}
				\begin{labeling}{Korrekte Addition}
					\item[\textcolor{Green}{Korrekte Addition:}] Beide Überträge sind gleich
					\item[\textcolor{red}{Überlauf:}] -sind ungleich
				\end{labeling}
				\paragraph{Wie wird sowas realisiert?}
				--Durch ein Antivalenzgatter.\\
				\\
				Antivalenz (aka. Kontravalenz, ausschließendes/exklusive Oder, XOR) ist das Gegenteil von Äquivalenz.
				
				\begin{table}[h]
					\centering
				\begin{tabular}{c|c}
					&\\ \hline
					00&0\\
					01&1\\
					10&1\\
					11&0\\
				\end{tabular}
				\caption{XOR}
				\end{table}
			
			\subsubsection{IEEE-P 754- Dloating-Point-Standard}
			\begin{table}[h]
				\centering
				\begin{tabular}{|c|c|c|}
					\hline
					 \(\overset{31}{\text{Vz}} \)& \(\overset{30}{\text{Ch}}\text{arakterist} \overset{23}{\text{ik}}\) & \(\overset{22}{\text{Ma}} \text{ntiss} \overset{0}{\text{e}}\) \\ \hline
				\end{tabular}
				\caption{32- Bit Maschinenformate des IEEE-Standards}
			\end{table}
		
		\begin{align*}
		\text{Vz } &\gets 1 \text{ Bit} \\
		\text{Charakteristik } &\gets 8 \text{ Bit}\\
		\text{Mantisse } &\gets  23 \text{ Bit}\\
		\end{align*}
						
		\begin{table}[h]
			\centering
			\begin{tabular}{|c|c|c|}
				\hline
				\(\overset{63}{\text{Vz}} \)& \(\overset{62}{\text{Ch}}\text{arakterist} \overset{52}{\text{ik}}\) & \(\overset{51}{\text{Ma}} \text{ntiss} \overset{0}{\text{e}}\) \\ \hline
			\end{tabular}
			\caption{64- Bit Maschinenformate des IEEE-Standards}
		\end{table}
	
	\begin{align*}
	\text{Vz } &\gets 1 \text{ Bit} \\
	\text{Charakteristik } &\gets 11 \text{ Bit}\\
	\text{Mantisse } &\gets  52 \text{ Bit}\\
	\end{align*}
	
	\begin{table}[h]
		\centering
		\begin{tabular}{|c|c|c|}
			\hline
			Charakteristik& \multicolumn{2}{c|}{Zahlenwert} \\ \hline
			0&\((-1^{Vz})0\) & \( \text{ Mantisse} \times 2^{-126}\) \\ 
			\\
			 \hl{Ab hier, bis 254}& \multicolumn{2}{c|}{\hl{Normalisierter Zahlenbereich}}\\
			1& \((-1^{Vz})1' \) & \( \text{ Mantisse} \times 2^{-126} \)\\
			\dots & \((-1^{Vz})1'\) &\( \text{ Mantisse} \times 2^{\text{Charakterristik}-126}\)\\
			254& \((-1^{Vz})1'\) & \( \text{ Mantisse} \times 2^{127}\)\\ \hline
			255&\multicolumn{2}{c|}{Mantisse \( = 0  \implies (-1)^{Vz} \infty \text{ overflow} \) }\\
			255&\multicolumn{2}{c|}{Mantisse \( \neq 0  \implies NaN \)} \\
			\hline
		\end{tabular}
		\caption{Gleitkommazahlen-Darstellung des 32-Bit-IEEE-Formats}
	\end{table}
	 ' \( \coloneqq \) implizierte 1\\
	 
	 \begin{table}[h]
	 	\centering
	 	\begin{tabular}{|c|c|c|}
	 		\hline
	 		Charakteristik& \multicolumn{2}{c|}{Zahlenwert} \\ \hline
	 		0&\((-1^{Vz})0\) & \( \text{ Mantisse} \times 2^{-1022}\) \\ 
	 		\\
	 		\hl{Ab hier, bis 2046}& \multicolumn{2}{c|}{\hl{Normalisierter Zahlenbereich}}\\
	 		1& \((-1^{Vz})1' \) & \( \text{ Mantisse} \times 2^{-1022} \)\\
	 		\dots & \((-1^{Vz})1'\) &\( \text{ Mantisse} \times 2^{\text{Charakterristik}-1023}\)\\
	 		2046& \((-1^{Vz})1'\) & \( \text{ Mantisse} \times 2^{1023}\)
	 		\\ \hline\\
	 		2047&\multicolumn{2}{c|}{Mantisse \( = 0  \implies (-1)^{Vz} \infty \text{ overflow} \) }\\
	 		2047&\multicolumn{2}{c|}{Mantisse \( \neq 0  \implies NaN \)} \\
	 		\hline
	 	\end{tabular}
	 	\caption{Gleitkommazahlen-Darstellung des 64-Bit-IEEE-Formats}
	 \end{table}
<<<<<<< HEAD
 	
 	\paragraph{32Bit-Beispiel:}
 	\paragraph{Charakteristik 1}
 	\begin{align*}
 		\text{\textcolor{Green}{$$0$$}} \text{\textcolor{blue}{$$000\; 0000\; 1$$}} \text{\textcolor{red}{$$000\; 0000 \dots 0000$$}} & = (1,0 \dots 00)_2 \times 2^{-126} &= \text{\hl{minreal}}  \\
 		\text{\textcolor{Green}{$$0$$}} \text{\textcolor{blue}{$$000\; 0000\; 1$$}} \text{\textcolor{red}{$$000\; 0000 \dots 0001$$}} & = (1,0 \dots 01)_2 \times 2^{-126} &= (1+2^{-23}) \times 2^{-126}  \\
 		\text{\textcolor{Green}{$$0$$}}\text{\textcolor{blue}{$$000\; 0000\; 1$$}}  \text{\textcolor{red}{$$000\; 0000 \dots 0010$$}} & = (1,0 \dots 10)_2 \times 2^{-126} &=  (1+2^{-22}) \times 2^{-126} \\
 		\text{\textcolor{Green}{$$0$$}} \text{\textcolor{blue}{$$000\; 0000\; 1$$}} \text{\textcolor{red}{$$000\; 0000 \dots 0011$$}} & = (1,0 \dots 11)_2 \times 2^{-126} &= (1+2^{-22} + 2^{-23} ) \times 2^{-126} \\
 	\end{align*}
 	
 	\paragraph{Charakterristik 2}
	\begin{align*}
		\text{\textcolor{Green}{$$0$$}} \text{\textcolor{blue}{$$000\; 0001\; 0$$}} \text{\textcolor{red}{$$000\; 0000 \dots 0000$$}} & = (1,0 \dots 00)_2 \times 2^{-125}  \\
		\text{\textcolor{Green}{$$0$$}} \text{\textcolor{blue}{$$000\; 0001\; 0$$}} \text{\textcolor{red}{$$000\; 0000 \dots 0001$$}} & = (1,0 \dots 01)_2 \times 2^{-125} &= (1+2^{-23}) \times 2^{-125}  \\
		\text{\textcolor{Green}{$$0$$}}\text{\textcolor{blue}{$$000\; 0001\; 0$$}}  \text{\textcolor{red}{$$000\; 0000 \dots 0010$$}} & = (1,0 \dots 10)_2 \times 2^{-125} &=  (1+2^{-22}) \times 2^{-125} \\
		\text{\textcolor{Green}{$$0$$}} \text{\textcolor{blue}{$$000\; 0001\; 0$$}} \text{\textcolor{red}{$$000\; 0000 \dots 0011$$}} & = (1,0 \dots 11)_2 \times 2^{-125} &= (1+2^{-22} + 2^{-23} ) \times 2^{-125} \\ 
	\end{align*}
	\paragraph{Sonderfälle}
			Nan:\\
			\colorbox{green!30}{$0$} \colorbox{blue!30}{$1111\;1111$} \colorbox{red!30}{$ \neq 0 $}\\
			\\
			\(- \infty\) :\\
			\colorbox{green!30}{$1$} \colorbox{blue!30}{$1111\;1111$} \colorbox{red!30}{$000\; 0000\; 0000\; 0000\; 0000\; 0000$}\\
			\\
			\(+ \infty\):\\
			\colorbox{green!30}{$0$} \colorbox{blue!30}{$1111\;1111$} \colorbox{red!30}{$000\; 0000\; 0000\; 0000\; 0000\; 0000$}\\
			\\
			0 :\\
			\colorbox{green!30}{$0$} \colorbox{blue!30}{$0000\;0000$} \colorbox{red!30}{$000\; 0000\; 0000\; 0000\; 0000\; 0000$}\\
			Oder:\\
			\colorbox{green!30}{$1$} \colorbox{blue!30}{$0000\;0000$} \colorbox{red!30}{$000\; 0000\; 0000\; 0000\; 0000\; 0000$}\\
			
		\subsection{Beispiel: Gleitkomma in Dezimal, Multiplikation und wieder Gleitkomma}
			Stellen Sie beide Gleitkommazahlen dezimal dar.\\
			Was ist das Ergebnis einer Multiplikation der Zahlen im Dezimalsystem?\\
			\\
			\begin{align*}
			x: \colorbox{green!30}{$1$} \colorbox{blue!30}{$1000\;0001$} \colorbox{red!30}{$110\; 1000\; 0000\; 0000\; 0000\; 0000$}\\
			y: \colorbox{green!30}{$1$} \colorbox{blue!30}{$0111\;1110$} \colorbox{red!30}{$101\; 0000\; 0000\; 0000\; 0000\; 0000$}\\
			\end{align*}
			\begin{align*}
			x: \colorbox{green!30}{$1$} \colorbox{blue!30}{$1000\;0001$} \colorbox{red!30}{$110\; 1000\; 0000\; 0000\; 0000\; 0000$}\\
			\colorbox{green!30}{$-$} \colorbox{blue!30}{$129-127$} \colorbox{red!30}{$110\; 1000\; 0000\; 0000\; 0000\; 0000$}\\
			\colorbox{green!30}{$-$}  \colorbox{red!30}{$(1+2^{-1} + 2^{-2} + 2^{-4}) \times 2^2$}\\
			\colorbox{green!30}{$-$}  \colorbox{red!30}{$1+ \frac{1}{2} +  \frac{1}{4} +  \frac{1}{16} \times 2^{2}$}\\
			\colorbox{green!30}{$-$}  \colorbox{red!30}{$1+ \frac{8}{16} +  \frac{4}{16} +  \frac{1}{16} \times 2^{2}$}\\
			\colorbox{green!30}{$-$}  \colorbox{red!30}{$1+ \frac{13}{16} \times 2^{2}$}\\
			\colorbox{green!30}{$-$}  \colorbox{red!30}{$1,8125  \times 2^{2}$}\\
			\colorbox{green!30}{$-$}  \colorbox{red!30}{$ 7,25 $}\\
			-7,25\\ \hline
			\end{align*}
			
			\begin{align*}
			y:\colorbox{green!30}{$1$} \colorbox{blue!30}{$0111\;1110$} \colorbox{red!30}{$101\; 0000\; 0000\; 0000\; 0000\; 0000$}\\
			\colorbox{green!30}{$-$} \colorbox{blue!30}{$0111\;1110$} \colorbox{red!30}{$101\; 0000\; 0000\; 0000\; 0000\; 0000$}\\
			\colorbox{green!30}{$-$} \colorbox{blue!30}{$2^1 + 2^2  + 2^3 + 2^4 + 2^5 + 2^6$} \colorbox{red!30}{$(1 + 2^{-1} + 2^{-3}) \times 2^{-1}$}\\
			\colorbox{green!30}{$-$} \colorbox{blue!30}{$2 + 4 + 8 + 16 + 32 + 64$} \colorbox{red!30}{$1,625 \times 2^{-1}$}\\
			\colorbox{green!30}{$-$} \colorbox{blue!30}{$126-127$} \colorbox{red!30}{$0,812.5$}\\
			\colorbox{green!30}{$-$} \colorbox{blue!30}{$-1$} \colorbox{red!30}{$0,812.5$}\\
			-0,8125\\ \hline
			\end{align*}
			
			\begin{align*}
			&-7,25 \times -0,8125\\
			&= 5,890625\\
			\end{align*}
			
			\begin{align*}
			5,890625 \rightarrow \text{ Dualzahl}\\
			\\
			5 \div 2 = 2 \quad R 1\\
			2 \div 2 = 1 \quad R 0\\
			1 \div 2 = 0 \quad R 1\\
			\\
			0,890625 &\times 2\\ 
			&= 1+ 0,78125\\
			&\times 2 = 1 + 0,5625\\ 
			&\times 2 = 1 + 0,125\\ 
			&\times 2 = 0 + 0,25\\ 
			&\times 2 = 0 + 0,5\\ 
			&\times 2 = 1 + 0,0\\ 
			\\
			\implies 101,111001\\\hline
			\\
			101,11001\\
			= 1,01111001 \times 2^{2}\\
			\text{Exponent } = 1\\
			2 + 127 = 129\
			\\
			129 \rightarrow \text{ Dualzahl}\\
			129\div 2 = 64 \quad R1\\
			\div 2 = 32 \quad R0\\
			\div 2 = 16 \quad R0\\
			\div 2 = 8 \quad R0\\
			\div 2 = 4 \quad R0\\
			\div 2 = 2 \quad R0\\
			\div 2 = 1 \quad R0\\
			\div 2 = 0 \quad R1\\
			\implies 10000001\\
			\\
			\text{Vorzeichenbit } \gets 0\\ \hline
			\\ 
			\colorbox{green!30}{$0$} \colorbox{blue!30}{$1000 \; 0001$} \colorbox{red!30}{$011\; 1100\; 1000\; 0000\; 0000\; 0000$}\\
			\end{align*}
=======
							
>>>>>>> ffb1a4ca34fac47b5fd00660bec7672d42a86918
	\section{Schaltnetze}
		
			Schaltnetze sind:
			\begin{easylist}
				& Rein kombinatorische logische Schaltungen
				& Kein Speicherverhalten
				& Realisierung logischer Funktionen
			\end{easylist}
		
			\subsubsection{Kontinuierliche und diskrete Signale}
				\begin{enumerate}
					\item Erfassen von Informationen mittels Sensoren
					\item Sensordaten müssen digitalisiert werden
					\item Algorithmen die das Signal/Sensordaten verarbeiten
				\end{enumerate}
			
				\begin{labeling}{Analoges Signal}
					\item[Ein Signal] ist eine Funktion einer unabhängigen variable t, die gewöhnlich die Zeit repräsentiert. Das Signal wird als \(U(t)\) angegeben.
					\item[Analoges Signal] \( U(t) \) ist zu jedem Zeitpunkt definiert und kann jeden beliebigen Wert annehmen (Signal mit kontinuierlichen Werten)
				\end{labeling}
				
				Gatter(?) wandelt jede Abtastperiode, \emph{analoges Signale}, \hl{Zeit- und wertkontinuierlich} ind \emph{Zeitdiskret und wertkontinuierlich}, durch Abtastung.\\
			
			\subsubsection{Binäre Signale}
				Es gibt mehrere Intervalle die einen zulässigen Wert darstellen:\\
				-- High- und Low-Intervall\\
				-- Der Bereich zwischen High und Low ist undefiniert\\
				\\
				Low ist über einem Minimalwert, damit durch Störgrößen nicht ein vermeintliches Signal generiert werden kann.
				
		\subsection{Formale Grundlagen}
			\subsubsection{Boolesche Algebra}
				George Boole 1815-1864\\
				
				\paragraph{Definition:}
				Als eine Boolesche Algebra bezeichnet man eine Menge \( V = \{ a,b,c, \dots \} \)\\
				auf der zwei zweistellige Operationen \(  \oplus \) XOR und \( \otimes \) derart erklärt sind,\\
				dass durch ihre Anwendung auf Elemente aus \( V \) wieder Elemente aus \( V \) entstehen \emph{(Abgeschlossenheit)}.\\
				\[ BA = [V, \oplus , \otimes ] \]
				Es gelten die vier \emph{Huntingtonschen Axiome} (H1-H4):\\
					Für alle \( a,b \in V \) gilt:\\
				\paragraph{H0 Abgeschlossenheit}
				\begin{align*}
					&a \otimes b \in V\\
					&a \oplus b \in V\\
				\end{align*}
				
				\paragraph{H1Kommutativgesetz}
				\begin{align*}
					&a \otimes b = b \otimes a\\
					&a \oplus b = b \oplus a \\
				\end{align*}
				
				\paragraph{H2 Distributivgesetz}
				\begin{align*}
					& a \otimes (b \oplus c) = (a \otimes b) \oplus (a \otimes c)\\
					& a \oplus (b \otimes c) = (a \oplus b) \otimes (a \oplus c)\\
				\end{align*}
				
				\paragraph{H3 Neutrale Elemente}
				\begin{align*}
					\text{Es Existieren zwei Elemente } e,n \in V \text{ so dass gilt:}&\\
					&a \otimes e = a & \text{Eins-Element}\\
					&a \oplus n = a &\text{Null-Element}\\
				\end{align*}
				
				\paragraph{H4 Inverse Elemente}
				\begin{align*}
					\text{Für } \forall a \in V \text{ existiert ein Element } \overline{a} \text{ so dass gilt:}&\\
					&a \otimes \overline{a} = n \\
					&a \oplus \overline{a} = e\\
				\end{align*}
				
				\paragraph{"Minimalste" Boolsche Algebra}
				\begin{align*}
					&BA = [V, \oplus , \otimes ] & V = \{ a,b,c, \dots \} \\
					&BA_{min} = [V_{min}, \oplus , \otimes ] & V_{min} = \{e, n\}\\ \hline
					\\
					\text{Ist TA }= [ \{0,1\}, +. \times ] \text{ eine Boolsche Algebra?}\\
					&\text{ ist nicht abgeschlossen bzgl. + }\\
					&1 + 1 = 2 \notin V\\ 
					\implies \text{TA ist keine Boolsche Algebra} &\\
				\end{align*}
				
				\paragraph{Eindeutigkeit des Eins-Elements}
				Es seien \(e_1\) und \(e_2\), zwei verschiedene Eins-Elemente, dann gilt:
				\begin{align*}
						&a \otimes e_1 = a &  \text{(H3) gilt auch für } a = e_2\\
						&e_2 \otimes e_1 = e_2 &\text{(1)}\\
						\\
						& a \otimes e_2 = a & \text{(H3) gilt auch für } a = e_1\\
						&e_1 \otimes e_2 = a & \text{(H3) gilt auch für } a = e_1\\
						\\
						&e_1 \otimes e_2 = e_1 &\text{(2)} \\
						\text{Aus (1) und (2) folgt } e_1 = e_2&\\
				\end{align*}
				
				\paragraph{Eindeutigkeit des Null-Elements}
				Es sein \(n_1\) und \(n_2\) zwei verschiedene Null-Elemente
				\begin{align*}
					&a \oplus n_1 = a & \text{(H3) gilt auch für } a = n_2\\
					&n_2 \oplus n_1 = n_2 &\text{(1)}\\
					\\
					& a \oplus n_2 = a & \text{(H3) gilt auch für } a = n_1\\
					& n_1 \oplus n_2 = n_1 & \text{(2)}\\
					\text{Aus (1) und (2) folgt } n_1 = n_2\\
				\end{align*}
				
				\paragraph{Eindeutigkeit des inversen Elements}
				Es seien \( \overline{a_1}\) und \( \overline{a_2}\) zwei verschiedene inverse Elemente für \(a\)
				\begin{align*}
					& a \oplus \overline{a_1} = n  & \text{(H4)}\\
					& a \otimes \overline{a_1} = e & \text{(H4)}\\
					\\
					&a \otimes \overline{a_2} = n& \text{(H4)}\\
					&a \oplus \overline{a_2} = e & \text{(H4)} \\
					\\
					\text{Distributivgesetz (H2)}\\
					\overline{a_1} \otimes \underbracket{( a \oplus \overline{a_2} )}_{= e} &= \underbracket{(\overline{a_1} \otimes a)}_{ = n} \oplus (\overline{a_1} \otimes \overline{a_2})\\
					 \overline{a_1} \otimes e &= n \oplus (\overline{a_1} \otimes \overline{a_2})\\
					\overline{a_1} &= \overline{a_1} \otimes \overline{a_2} & \text{(1)}\\
					\\
					\overline{a_2} \times ( a \oplus \overline{a_1}) &= (\overline{a_2} \otimes a) \oplus (\overline{a_2} \otimes \overline{a_1}) & \text{(H2)}\\
					&\vdots\\
					 \overline{a_2} &= \overline{a_2} \otimes \overline{a_1} & \text{(2)}\\
					\text{Aus (1) und (2) folgt: }  \overline{a_1} &= \overline{a_2} \implies a_1 = a_2\\
				\end{align*}
				
			 \paragraph{Mengenalgebra vs. Boolsche Algebra}
				 \begin{table}[H]
				 	\centering
				 	\begin{tabular}{|l|c|c|}
				 		\hline
				 		&Boolesche Algebra& Mengen Algebra\\ \hline
				 		Potenzmenge einer Grundmenge& \( V \) & \( \varphi (T) \)\\
				 		Vereinigung& \( \oplus \) &\( \cup \)\\
				 		Durchschnitt&\( \otimes \) & \( \cap \) \\
				 		Leere Menge& \( n \) & \( \emptyset \) \\
				 		Grundmenge& \( e \) & \( T \)\\
				 		Komplementmenge von A & \( \overline{a} \)  & \( \overline{A} \) \\ \hline
				 	\end{tabular}
			 	\caption{Vergleich Boolesche Algebra \& Mengen Algebra}
				 \end{table}
				 
				 \paragraph{Mengenalgebra}	
				 
				 Verknüpfungsgebilde: \(MA = [ \varphi (M), \cap , \cup ]\)
				 \begin{align*}
				 	\forall S, T, R \in \varphi(M) \text{ gilt:}&\\
				 	\\
				 \end{align*}
				 	
				 	H0 \( \varphi (m)\) ist abgeschlossen bzgl. \( \cap \) und \( \cup \)
				\begin{align*}
				 	S \cap T &\in \varphi (M) \\
				 	S \cup T &\in \varphi (M)\\
				 	\\
				\end{align*}
				 	
				 	H1 Kommutativgesetz:
			 	\begin{align*}
				 	S \cap T  &= T \cap S \\
				 	S \cup T &= T \cup S \\
				 	\\
				\end{align*}
				 	
				 	H2 Distributivgesetz:
			 	\begin{align*}
				 	R \cap (S \cup T)& = ( R \cap S) \cup ( R \cap T)\\
				 	R \cup (S \cap T) &= ( R \cup S) \cap ( R \cup T)\\
				 	\\
				\end{align*}
				 	
				 H3 Neutrale Elemente:
			 	\begin{align*}
				 	S &\cap M = S\\
				 	S &\cup \emptyset = S\\
				 	\\
			   	\end{align*}
			   	
				   	H4 Inverse Elemente:
			  	\begin{align*}
				 	S \cap \overline{S} &= \emptyset \\
				 	S \cup \overline{S} &= M \\
				 \end{align*}
				 
				 \begin{table}[H]
				 	\centering
				 	\begin{tabular}{|l|l|l|}
				 		\hline
				 		&Mengenalgebra & Boolesche Algebra\\ \hline
				 		&\( \varphi (M) \) & \( V \) \\
				 		&\( S \in \varphi (M) \text{ oder} \) & \( a \in V \) \\
				 		&\(  S \subseteq M  \)& \\ \hline
				 		&\( \overline{S} \) & \( \overline{a} \) \\
				 		Operatoren &\( \cap , \cup  \) & \( \oplus , \otimes \)  \\
				 		Eins-Element &\( M \in \varphi (M) \) & \( e \in V \)  \\
				 		Null-Element &\( \emptyset \in \varphi(M) \) & \( n \in V \) \\ \hline
				 	\end{tabular}
				 \end{table}				 
				 
				 \paragraph{Schaltalgebra }
				 Spezielle Boolesche Algebra
				 \begin{table}[H]
				 	\centering
				 	\begin{tabular}{|c|c|c|}
				 		\hline
				 		Boolesche Algebra & Schaltalgebra&\\ \hline
				 		\( V \) & \( \{ 0, 1 \}  \) &\\
				 		\( \oplus \) & \( \vee \)  & Disjunktion \\
				 		\( \otimes \) & \( \wedge \)  & Konjunktion\\
				 		\( n \) & \( 0 \)& \\
				 		\( e \) & \( 1 \) &\\ 
				 		\( \overline{a} \) & \( \overline{a} \) &\\ \hline
				 	\end{tabular}
				 \end{table}
				 
				 \paragraph{Huntingtonsche Axiome in der Schaltalgebra}
				 
				 H0 Abgeschlossenheit \\
				 H1 Assoziativgesetz:
				 \[ a \vee b = b \vee a \]
				 \[ a \wedge b = b \wedge a \]
				 \\
				 H2 Distributivgesetz: 
				 \[ a \wedge ( b \vee c) = ( a \wedge b) \vee ( a \wedge c ) \]
				 \[ a \vee ( b \wedge c) = ( a \vee b) \wedge ( a \vee c ) \]\\
				 \\
				 H3 Neutrales Element:
				 \[ a \vee 0 = a \]
				 \[ a \wedge 1 = a \]
				 \\
				 H4 inverses Element:
				 \[ a \wedge \overline{a} = 0 \]
				 \[ a \vee \overline{a} = 1 \]
				 
				 \paragraph{0:35:09 Dualitätsprinzip}
				 Doppelte gemoppelte Axiome\\
				 Jeder Operator und 0 und 1, lässt sich durch das jeweilige Gegenteil ersetzen\\
				 Vorteil beim Beweisen\\
				 Das Prinzip: \\
				 \begin{easylist}
				 	& Ersetze:
				 		&& \( \vee \iff \wedge \)
				 		&& \( 0 \iff 1 \)
				 	& Belasse:
				 		&& \( a \iff a \)
				 		&& \( \overline{a} \iff \overline{a} \)
				 \end{easylist}
				 \[ a \wedge ( b \vee c) = ( a \wedge b) \vee ( a \wedge c ) \]
				 \[ a \vee ( b \wedge c) = ( a \vee b) \wedge ( a \vee c ) \]
				 \[ \iff a [\vee \wedge] ( b [\wedge \vee] c) = ( a [\vee \wedge] b) [\wedge \vee] ( a [\vee \wedge] c )  \]
				 
				 Huntingtonische Axiome sind nicht beweisbar\\
				 
				 \paragraph{Aus den vier Huntingtonischen Axiomen lassen sich weitere Sätze ableiten}
				 Assoziativgesetze: 
				 \[ a \wedge ( b \vee c) = ( a \wedge b) \vee ( a \wedge c ) = a \wedge b \wedge c \]
				 \[ a \vee ( b \wedge c) = ( a \vee b) \wedge ( a \vee c ) a \vee b \vee c \]
				 
				 Idempotenzgesetze:
				 \[ a \wedge a = a \]
				 \[ a \vee a = a \]
				 
				 Absorptionsgesetze:
				 \[ a \wedge ( a \vee b ) = a \]
				 \[ a \vee ( a \wedge b ) = a \]
				 
				 DeMorgan-Gesetze:
				 \[ \overline{a \wedge b } = \overline{a} \vee \overline{b} \]
				 \[ \overline{a \vee b } = \overline{a} \wedge \overline{b} \]
				 
				 \paragraph{Beweis: DeMorgan \( \overline{a \wedge b} = \overline{a} \vee \overline{b} \)} 
				 Zu zeigen : \( (\overline{a} \vee \overline{b}) \) das Komplementelement von \( (a \wedge B) \)\\
				UND Komplementgesetze \( (x \vee \overline{x} = 1) \) und \( (x \wedge \overline{x} = 0 ) \) sind erfüllt.\\
				 \begin{align*}
				 	x = a \wedge b\\
				 	(a \wedge b) \vee ( \overline{a} \vee \overline{b} ) &= (a \vee \overline{a} \vee \overline{b} ) \wedge (b \vee \overline{a} \vee \overline{b} ) \\
				 	&= (1 \vee \overline{b}) \wedge (1 \vee \overline{a} ) \\
				 	&= 1 \wedge 1 \\
				 	&= 1\\
				 	\\
				 	(a \wedge b) \wedge ( \overline{a}\overline{b}) &= (a \wedge b \wedge \overline{a}) \vee (a \wedge b \wedge \overline{b}) \\
				 	&= 0 \vee 0\\
				 	&= 0\\
				 \end{align*}
				 \emph{Dualitätsprinzip} ermöglicht auch hier den aus Tausch innerhalb der Dualität.\\
				 
				 \subsubsection{Schaltalgebra}
				 Eingänge \( \iff \) Ausgänge \\
				 Spannung kann \emph{\hl{Low}} und \emph{\hl{High}} sein. \\
				 Low \( \eqqcolon \) 0 \\
				 High \( \eqqcolon \) 1,\\
				 in der \emph{positiven Logik}.\\
				 
				 \paragraph{Serien- \& Parallelschaltungen}
				 \begin{labeling}{Parralelschaltung}
				 	\item[Serienschaltung] Ist true wenn beide Schalter \(x_1, x_2 \) geschlossen sind.
				 	\item[Parralelschaltung] Ist true wenn einer der beiden Schalter \(x_1, x_2 \) geschlossen ist.
				 \end{labeling}
				 
				 \paragraph{Überprüfung: Gilt die boolesche Algebra}
				 
				 
				 H0 Abgeschlossenheit:
				 \[ x_1 \text{ ser } x_2 \in \{ L, H \} \]
				 \[ x_1 \text{ par } x_2 \in \{ L, H \} \]
				 
				 H1 Kommutativgesetze:
				 \[x_1 \text{ ser }  x_2 = x_2 \text{ ser } x_1 \]
				 \[x_1 \text{ par } x_2 = x_2 \text{ par } x_1 \]
				 
				 H2 Distributivgesetze
				 \[ x_1 \text{ ser } (x_2 \text{ par }  x_3 ) = (x_1 \text{ ser } x_2) \text{ par }  (x_1 \text{ ser } x_3) \]
				 \[ x_1 \text{ par }  (x_2 \text{ ser } x_3 ) = (x_1 \text{ par }  x_2) \text{ ser } (x_1 \text{ par }  x_3) \]
				 
				 H3 Neutrale Elemente:\\
				 \( V \eqqcolon \) Dauernde Verbindung
				 \[ x \text{ \text{ par }  } V = x \]
				 \\
				 \( U \eqqcolon \) Dauernde Unterbrechung\\
				 \[ x \text{ par }  U = x \]
				 
				 H4 Inverse Element
				 \[x \text{ ser } \overline{x} = U \]
				 \[x \text{ ser }  \overline{x} = V \]
				 
				 \begin{table}[H]
				 	\centering
				 	\begin{tabular}{|c c c|}
				 		\hline
				 		&Boolesche Algebra & \\
				 		& \( BA = [V, \oplus , \otimes  ] \) &\\
				 		Mengenalgebra & & Binäre Algebra \\
				 		\( MA = [ P(M), \cap , \cup  ] \) && \(BA2 = [ \{ n, e \}, \oplus , \otimes ] \) \\
				 		&&\\
				 		Binäre Mengenalgebra && Schaltalgebra\\
				 		\(MA2 = [\{ \emptyset , M  \}, \cap , \cup ]\) && \( SA = [\{0, 1 \}, \wedge , \vee] \)\\
				 		&Aussagenlogik&\\
				 		&\( AL = [{\text{falsch, wahr}}, \text{UND, ODER} ] \)&\\ \hline
				 	\end{tabular}
			 	\caption{Ungefähre Anordnung und Aufzählung der Logiken, von oben nach unten}
				 \end{table}
				 
				 \paragraph{0:45:56 Schaltalgebra }
				 \paragraph{0:54:17 2-wertige ,,binäre"" algebraische Strukturen }
				 \paragraph{0:55:23 Zusammenfassung: Boolesche Algebra }
				 \paragraph{0:56:01 Boolescher Ausdruck }
				 \paragraph{0:59:21 Boolesche Funktionen }
				 \paragraph{1:03:39 EInstellige boolsche Funktion }
				 \paragraph{1:04:33 zweistellige Boolsche Funktion }
				 
				 \paragraph{Auswertung}
				 Bindungsrangfolge:
				 \begin{easylist}{enumerate}
				 	& Negation \( \neg \)
				 	& Konjunktion \( \wedge \)
				 	& Disjunktion \( \vee \)
				 \end{easylist}
				 Klammern können eine andere Reihenfolge festlegen.\\
				 
				 \paragraph{Def. Vollständige Operationsysteme} 
				 Ein \emph{System von Operatoren}, \\
				 mit dem \emph{alle booleschen Funktionen dargestellt} werden können,\\
				 heißt \emph{\hl{vollständiges Operatorensystem}}.\\
				 \\
				 Die Operatoren \[ \wedge \vee \overline{\phantom{A}} \] bilden ein vollständiges Operatorensystem.\\
				 \paragraph{Beispiel:}
				 \[ a \iff b \] liefert das gleiche Ergebnis wie \[ (a \wedge b) \vee ( \overline{a} \wedge\overline{b}) \]\\
				 \( \iff \) lässt sich durch die Grundoperationen \(  \wedge, \vee \) und \( \overline{\phantom{A}} \) ersetzen.\\
				 
				 \paragraph{Motivierende Beispiele}
				 Prüfen ob es um ein vollständiges Operatorensystem handelt:\\
				 Wir nehmen NAND bzw. \(  \overline{\wedge}   \) .\\
				 Zu prüfen ist ob NAND,\\
				 Konjunktion, Disjunktion, Negation ersetzen kann. Also für:\\
				 \begin{align*}
				 	&\overline{x}\\
				 	x &\wedge y \\
				 	x &\vee y \\
				 \end{align*}
				 
				 Substitutionen finden.\\
				 \paragraph{Beispiel: NAND \(\overline{\wedge} \)}
				 \begin{align*}
				 	&a \overline{\wedge} a \\
				 	=& \overline{a \wedge a}\\
				 	=& \overline{a}\\
				 	 \implies & \text{Negation gefunden!}\\
				 	\\ 
				 	&(a \bar{\wedge} b) \bar{\wedge} (a \bar{\wedge} b) \\
				 	=& \overline{ (\overline{a \wedge b}) \wedge (\overline{ a \wedge b }) }\\
				 	=& \overline{(\overline{a \wedge b})}\\
				 	=& a \wedge b\\
				 	 \implies & \text{Konjunktion gefunden!}\\
				 	\\
				 	&(a \bar{\wedge} a) \overline{\wedge} ( b \wedge \bar{b} ) \\
				 	=& \overline{ (\overline{a \wedge b}) \wedge (\overline{ a \wedge b }) } \\
				 	=& \overline{ \bar{a} \wedge \bar{b} }\\
				 	=& a \vee b\\
				 	 \implies & \text{Disjunktion gefunden!}\\
				 	\implies \implies & \text{Ja NAND ist ein vollständiges Operatorensystem}\\
				 	\\
				 	\bar{\vee}& \text{ NOR funktioniert Analog dazu!}
				 \end{align*}
				 
				 \paragraph{Weiteres Beispiel Konjunktion, Kontravalenz}
				 Bemerkung: \( (\wedge, \nleftrightarrow) \) alleine ist kein vollständiges Operatoren System, man braucht eine "1"  \[ (\wedge , \nleftrightarrow , 1) \]
				 
				 \begin{align*}
				 	( \wedge , \nleftrightarrow ) \coloneqq (\wedge \nleftrightarrow , 1 )\\
				 	\\
				 	a \nleftrightarrow 1& \\
				 	=& \overline{a} \wedge 1 \vee a \wedge \underbrace{\overline{1}}_{=0} \\
				 	=& \overline{a}\\
				 	\implies & \text{Negation gefunden}\\
				 	\\
				 	a \nleftrightarrow b \nleftrightarrow ( a \wedge b ) &\\
				 	=& a \nleftrightarrow (b \wedge ( \overline{a \wedge b)} \vee \underbrace{\overline{b} \wedge ( a \wedge b}_{=0} )\\
				 	=& a \nleftrightarrow (b \wedge (\overline{a} \vee \overline{b})) \vee 0 \\
				 	=& a \nleftrightarrow (b \wedge \overline{a})\\
				 	=& a \wedge (\overline{b \wedge \overline{a}}) \vee \overline{a} \wedge ( b \wedge \overline{a} )\\
				 	=& a \wedge (\overline{b} \vee a) \vee \overline{a} \wedge  b \wedge \overline{a} \\
				 	=& a \wedge (\overline{b} \vee a) \vee \overline{a} \wedge  b  \\
				 	=& \underbrace{(a \wedge \overline{b} ) \vee a}_{=a} \vee (\overline{a} \wedge b)\\
				 	=& a \vee (\overline{a} \wedge b) \\
				 	=& (\underbrace{a \vee \overline{a}}_{=1}) \wedge ( a \vee b )\\
				 	=& a \vee b \\
				 \end{align*}
				 
				 \paragraph{Alle Operatorensysteme}
				 \begin{table}
				 	\centering
				 	\begin{tabular}{|r|c|c|c|}
				 		\hline
				 		Operatorensysteme & Negation & Konjunktion & Disjunktion \\ \hline
				 		\( \wedge , \vee , \overline{\phantom{A}}  \) & \( \bar{a} \) & \( a \wedge b \) & \( a \vee b \) \\
				 		\( \wedge, \overline{\phantom{A}} \) & \( \bar{a} \) & \( a \wedge b \) & \( \overline{ \bar{a} \wedge \bar{b} } \) \\
				 		\( \vee , \overline{\phantom{A}} \) & \( \bar{a} \) & \( \overline{\bar{a} \vee \bar{b} } \) & \( a \vee b \) \\
				 		\( \bar{\wedge} \) & \( a \bar{\wedge} a \) & \( (a \bar{\wedge} b) \bar{\wedge} ( a \bar{\wedge} b ) \) & \( (a \bar{\wedge} a) \bar{\wedge} ( b \bar{\wedge} b) \) \\
				 		\( \bar{\vee} \)  & \(a \bar{\vee} a\) & \( (a \bar{\vee} a) \bar{\vee} ( b \bar{\vee} b )  \) & \((a \bar{\vee} b) \bar{\vee} ( a \bar{\vee}b)  \) \\
				 		\( \wedge, \nleftrightarrow \)& \(a \nleftrightarrow  1\)  & \( a \wedge b \) & \(a \nleftrightarrow b \nleftrightarrow  ( a \wedge b) \) \\ \hline
				 	\end{tabular}
				 \end{table}
				 
				 \paragraph{Tautologie}
					Wann repräsentieren zwei Ausdrücke A und B die selbe Boolesche Funktion?\\
					Anders aus gedrückt: Ist \( A \iff B \) eine Tautologie?\\
					\\
					\paragraph{Beispiel}
					Gegeben sind zwei Boolesche Funktionen:
					\begin{align*}
						f_1(a,b) &= (a \wedge b) \vee (\bar{a} \wedge \bar{b})\\
						f_1(a,b) &= (a \vee \bar{b} ) \wedge (\bar{a} \vee b)\\
					\end{align*}
					Sind \(f_1\) und \(f_2\) identisch oder \\
					ist \[ (a \wedge b) \vee (\bar{a} \wedge \bar{b}) \iff (a \vee \bar{b} ) \wedge (\bar{a} \vee b) \] eine Tautologie?\\
					
					\paragraph{Wie kann man das beweisen?}
					Mit Hilfe einer Funktionstabelle (/ Früher: Wahrheitstafeln) oder mittel Umformungen mit Hilfe der algebraischen Gesetze.\\
					\\
					Zwei Ausdrücke sind äquivalent, fall die Ergebnisse ihrer Auswertung für alle möglichen Kombinationnen von Variablenbelegungen äquivalent sind. 
					\begin{table}[H]
						\centering
						\begin{tabular}{|c c|c|c|c|}
							\hline
							a&b&\( x = (a \wedge b) \vee (\bar{a} \wedge \bar{b}) \)& \(y = ( a \vee \bar{b} ) \wedge (\bar{a} \vee b ) \)& \( x \iff x\)\\ \hline 
							0&0&1&1&1\\
							0&1&0&0&1\\
							1&0&0&0&1\\
							1&1&1&1&1\\ \hline
						\end{tabular}
					\end{table}
			
			\subsubsection{Normalformen}
			\subsubsection{Minimalformen}
			\subsubsection{Funktionsdarstellung im Würfelkalkül}
			\subsubsection{NAND/NOR-Konversion}
			
		\subsection{Realisierung von Schaltnetzen}
		\subsection{Entwurf von Schaltnetzen}
		\subsection{Laufzeiteffekte}
	
	\section{Schaltwerke}
	\section{Rechnerarithmetik}
	
\end{document}
